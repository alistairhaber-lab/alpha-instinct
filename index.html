<script>
  // Your Make webhook URL
  const MAKE_WEBHOOK_URL = "https://hook.us2.make.com/tz2cj70cjfxv2i3q20qzmfugdncy64b5";

  const statusEl = document.getElementById("status");
  const topStatus = document.getElementById("topStatus");
  const briefingBox = document.getElementById("briefingBox");
  const submitBtn = document.getElementById("submitBtn");
  const scenarioButtons = document.getElementById("scenarioButtons");
  const scenarioSelect = document.getElementById("scenario");
  const useLocationCheckbox = document.getElementById("useLocation");
  const latInput = document.getElementById("lat");
  const lonInput = document.getElementById("lon");
  const formInputs = {
    address: document.getElementById("address"),
    household: document.getElementById("household"),
    vehicles: document.getElementById("vehicles"),
    meds: document.getElementById("meds"),
    email: document.getElementById("email")
  };

  // Tools
  const compassTool = document.getElementById("compassTool");
  const flashlightTool = document.getElementById("flashlightTool");
  const compassPanel = document.getElementById("compassPanel");
  const flashlightPanel = document.getElementById("flashlightPanel");
  const compassNeedle = document.getElementById("compassNeedle");
  const compassValue = document.getElementById("compassValue");
  const compassStatus = document.getElementById("compassStatus");
  const flashlightToggle = document.getElementById("flashlightToggle");
  const flashlightStatus = document.getElementById("flashlightStatus");

  let pendingLocation = false;
  let compassActive = false;
  let orientationHandler = null;
  let flashlightStream = null;

  // Scenario buttons -> hidden select
  scenarioButtons.addEventListener("click", (e) => {
    const btn = e.target.closest(".scenario-btn");
    if (!btn) return;
    document.querySelectorAll(".scenario-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    const value = btn.getAttribute("data-value");
    scenarioSelect.value = value;
  });

  // GPS toggle
  useLocationCheckbox.addEventListener("change", () => {
    if (!useLocationCheckbox.checked) {
      latInput.value = "";
      lonInput.value = "";
      return;
    }

    if (!navigator.geolocation) {
      statusEl.textContent = "Geolocation not supported on this device.";
      statusEl.className = "status-text error";
      useLocationCheckbox.checked = false;
      return;
    }

    statusEl.textContent = "Requesting GPS positionâ€¦";
    statusEl.className = "status-text";
    topStatus.classList.add("loading");
    topStatus.querySelector("span").textContent = "Locking location";

    pendingLocation = true;

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        latInput.value = latitude;
        lonInput.value = longitude;
        statusEl.textContent = "Location locked.";
        statusEl.className = "status-text success";
        topStatus.classList.remove("loading");
        topStatus.querySelector("span").textContent = "Ready with GPS";
        pendingLocation = false;
      },
      (err) => {
        console.error(err);
        statusEl.textContent = "Could not get GPS. You can still use your typed address.";
        statusEl.className = "status-text error";
        useLocationCheckbox.checked = false;
        topStatus.classList.remove("loading");
        topStatus.querySelector("span").textContent = "Ready (no GPS)";
        pendingLocation = false;
      },
      { enableHighAccuracy: false, timeout: 7000, maximumAge: 60000 }
    );
  });

  // Submit handler â€“ **this is the important changed part**
  submitBtn.addEventListener("click", async (e) => {
    e.preventDefault();

    if (pendingLocation) {
      statusEl.textContent = "Still acquiring locationâ€¦";
      statusEl.className = "status-text";
      return;
    }

    const scenario = scenarioSelect.value;
    const full_address = formInputs.address.value || "";
    const household = formInputs.household.value || "";
    const vehicles = formInputs.vehicles.value || "";
    const medications = formInputs.meds.value || "";
    const email = formInputs.email.value || "";
    const lat = latInput.value ? Number(latInput.value) : null;
    const lon = lonInput.value ? Number(lonInput.value) : null;

    if (!full_address.trim()) {
      statusEl.textContent = "Add at least a rough location.";
      statusEl.className = "status-text error";
      return;
    }

    const payload = {
      scenario,
      full_address,
      household,
      vehicles,
      medications,
      email,
      lat,
      lon
    };

    statusEl.textContent = "Generating briefingâ€¦";
    statusEl.className = "status-text";
    submitBtn.disabled = true;
    topStatus.classList.add("loading");
    topStatus.classList.remove("error");
    topStatus.querySelector("span").textContent = "Building your plan";

    try {
      const res = await fetch(MAKE_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        throw new Error("Server responded with " + res.status);
      }

      const raw = await res.text();
      let htmlToRender = "";

      // 1) If backend returns JSON { briefing_text: "..." }
      try {
        const maybeJson = JSON.parse(raw);
        if (maybeJson && typeof maybeJson.briefing_text === "string") {
          htmlToRender = maybeJson.briefing_text;
        }
      } catch {
        // 2) Not JSON â†’ treat the whole thing as HTML from Grok
        htmlToRender = raw;
      }

      if (!htmlToRender || !htmlToRender.trim()) {
        throw new Error("Empty briefing from backend.");
      }

      // ðŸ”¥ Render as real HTML, not plain text
      briefingBox.innerHTML = htmlToRender;

      statusEl.textContent = "Briefing generated.";
      statusEl.className = "status-text success";
      topStatus.classList.remove("loading", "error");
      topStatus.querySelector("span").textContent = "Briefing updated";
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Error generating briefing. Try again in a moment.";
      statusEl.className = "status-text error";
      topStatus.classList.remove("loading");
      topStatus.classList.add("error");
      topStatus.querySelector("span").textContent = "Error from pipeline";
    } finally {
      submitBtn.disabled = false;
    }
  });

  // Compass helpers
  function stopCompass() {
    if (orientationHandler) {
      window.removeEventListener("deviceorientationabsolute", orientationHandler);
      window.removeEventListener("deviceorientation", orientationHandler);
      orientationHandler = null;
    }
    compassActive = false;
    compassPanel.classList.remove("visible");
  }

  function startCompass() {
    if (!("DeviceOrientationEvent" in window)) {
      compassStatus.textContent = "Compass not supported on this device.";
      compassPanel.classList.add("visible");
      return;
    }

    const enable = () => {
      compassPanel.classList.add("visible");
      compassStatus.textContent = "Move device slowly to get stable heading.";
      compassActive = true;

      orientationHandler = (event) => {
        let heading = null;

        if (typeof event.webkitCompassHeading === "number") {
          heading = event.webkitCompassHeading; // iOS
        } else if (typeof event.alpha === "number") {
          heading = 360 - event.alpha; // others
        }

        if (heading != null && !isNaN(heading)) {
          const normalized = (heading + 360) % 360;
          compassNeedle.style.transform = `translateX(-50%) rotate(${normalized}deg)`;
          compassValue.textContent = `${Math.round(normalized)}Â°`;
        }
      };

      window.addEventListener("deviceorientationabsolute", orientationHandler, true);
      window.addEventListener("deviceorientation", orientationHandler, true);
    };

    if (
      typeof DeviceOrientationEvent !== "undefined" &&
      typeof DeviceOrientationEvent.requestPermission === "function"
    ) {
      DeviceOrientationEvent.requestPermission()
        .then((state) => {
          if (state === "granted") enable();
          else {
            compassStatus.textContent = "Permission denied for motion sensors.";
            compassPanel.classList.add("visible");
          }
        })
        .catch(() => {
          compassStatus.textContent = "Unable to access motion sensors.";
          compassPanel.classList.add("visible");
        });
    } else {
      enable();
    }
  }

  compassTool.addEventListener("click", () => {
    if (compassActive) {
      stopCompass();
    } else {
      stopCompass();
      startCompass();
    }
  });

  // Flashlight toggle (best-effort, not all devices support this)
  async function toggleFlashlight() {
    if (flashlightStream) {
      flashlightStream.getTracks().forEach((t) => t.stop());
      flashlightStream = null;
      flashlightToggle.classList.remove("active");
      flashlightStatus.textContent = "Flashlight off.";
      return;
    }

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      flashlightStatus.textContent = "Flashlight control not supported.";
      return;
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }
      });
      const track = stream.getVideoTracks()[0];
      const capabilities = track.getCapabilities ? track.getCapabilities() : {};

      if (capabilities.torch) {
        await track.applyConstraints({ advanced: [{ torch: true }] });
        flashlightStream = stream;
        flashlightToggle.classList.add("active");
        flashlightStatus.textContent = "Flashlight on. Tap again to turn off.";
      } else {
        flashlightStatus.textContent = "Torch not supported; using camera only.";
        flashlightStream = stream;
        flashlightToggle.classList.add("active");
      }
    } catch (err) {
      console.error(err);
      flashlightStatus.textContent = "Unable to access flashlight/camera.";
    }
  }

  flashlightTool.addEventListener("click", () => {
    const visible = flashlightPanel.classList.contains("visible");
    flashlightPanel.classList.toggle("visible", !visible);
  });

  flashlightToggle.addEventListener("click", (e) => {
    e.preventDefault();
    toggleFlashlight();
  });

  window.addEventListener("beforeunload", () => {
    if (flashlightStream) {
      flashlightStream.getTracks().forEach((t) => t.stop());
    }
  });
</script>
